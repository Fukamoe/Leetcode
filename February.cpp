#include "February.h"




//class Solution {
//public:
//    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {
//        int sumA = accumulate(A.begin(), A.end(), 0);
//        int sumB = accumulate(B.begin(), B.end(), 0);
//        int delta = (sumA - sumB) / 2;
//        unordered_set<int> rec(A.begin(), A.end());
//        vector<int> ans;
//        for (auto& y : B) {
//            int x = y + delta;
//            if (rec.count(x)) {
//                ans = vector<int>{ x, y };
//                break;
//            }
//        }
//        return ans;
//    }
//};
//
//class DualHeap {
//private:
//    // 大根堆，维护较小的一半元素
//    priority_queue<int> small;
//    // 小根堆，维护较大的一半元素
//    priority_queue<int, vector<int>, greater<int>> large;
//    // 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数
//    unordered_map<int, int> delayed;
//
//    int k;
//    // small 和 large 当前包含的元素个数，需要扣除被「延迟删除」的元素
//    int smallSize, largeSize;
//
//public:
//    DualHeap(int _k) : k(_k), smallSize(0), largeSize(0) {}
//
//private:
//    // 不断地弹出 heap 的堆顶元素，并且更新哈希表
//    template<typename T>
//    void prune(T& heap) {
//        while (!heap.empty()) {
//            int num = heap.top();
//            if (delayed.count(num)) {
//                --delayed[num];
//                if (!delayed[num]) {
//                    delayed.erase(num);
//                }
//                heap.pop();
//            }
//            else {
//                break;
//            }
//        }
//    }
//
//    // 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求
//    void makeBalance() {
//        if (smallSize > largeSize + 1) {
//            // small 比 large 元素多 2 个
//            large.push(small.top());
//            small.pop();
//            --smallSize;
//            ++largeSize;
//            // small 堆顶元素被移除，需要进行 prune
//            prune(small);
//        }
//        else if (smallSize < largeSize) {
//            // large 比 small 元素多 1 个
//            small.push(large.top());
//            large.pop();
//            ++smallSize;
//            --largeSize;
//            // large 堆顶元素被移除，需要进行 prune
//            prune(large);
//        }
//    }
//
//public:
//    void insert(int num) {
//        if (small.empty() || num <= small.top()) {
//            small.push(num);
//            ++smallSize;
//        }
//        else {
//            large.push(num);
//            ++largeSize;
//        }
//        makeBalance();
//    }
//
//    void erase(int num) {
//        ++delayed[num];
//        if (num <= small.top()) {
//            --smallSize;
//            if (num == small.top()) {
//                prune(small);
//            }
//        }
//        else {
//            --largeSize;
//            if (num == large.top()) {
//                prune(large);
//            }
//        }
//        makeBalance();
//    }
//
//    double getMedian() {
//        return k & 1 ? small.top() : ((double)small.top() + large.top()) / 2;
//    }
//};
//
//class Solution {
//public:
//    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
//        DualHeap dh(k);
//        for (int i = 0; i < k; ++i) {
//            dh.insert(nums[i]);
//        }
//        vector<double> ans = { dh.getMedian() };
//        for (int i = k; i < nums.size(); ++i) {
//            dh.insert(nums[i]);
//            dh.erase(nums[i - k]);
//            ans.push_back(dh.getMedian());
//        }
//        return ans;
//    }
//};
